# 图论

## 树 Hash

素数 Hash + 双保险

```cpp
typedef unsigned long long ULL;
namespace treehash {
    vector<int> *G;
    int n;
    using math::prime;
    const int mod = 998244353;
    inline ULL pack(ULL val, int sz) {
        return 2ull + 3ull * val + 7ull * prime[sz + 1];
    }

    int siz[N];

    ULL hashval[N], hashrt[N];
    ULL srchashval[N], srchashrt[N];
    inline int add(int x, int y) {
        x += y;
        return x >= mod ? x -= mod : x;
    }
    inline int sub(int x, int y) {
        x -= y;
        return x < 0 ? x += mod : x;
    }
    inline int mul(int x, int y) { return 1ll * x * y % mod; }

    void predfs(int u, int ff) {
        siz[u] = 1;
        hashval[u] = 1;
        int sz = 0;
        for (int v : G[u]) {
            if (v == ff) continue;
            predfs(v, u);
            sz++;
            siz[u] += siz[v];
            hashval[u] += hashval[v] * prime[siz[v]];
        }
        srchashval[u] = hashval[u];
        hashval[u] = pack(hashval[u], siz[u]);
    }
    void dfs(int u, int ff) {
        for (int v : G[u]) {
            if (v == ff) continue;
            ULL tmp = srchashrt[u] - hashval[v] * prime[siz[v]];
            tmp = pack(tmp, n - siz[v]);
            
            srchashrt[v] = srchashval[v] + tmp * prime[n - siz[v]];
            hashrt[v] = pack(srchashrt[v], n);
            dfs(v, u);
        }
    }

    vector<ULL> gethash(int _n, vector<int> _G[]) {
        n = _n;
        G = _G;
        vector<ULL> res(0);
        predfs(1, 0);
        hashrt[1] = hashval[1];
        srchashrt[1] = srchashval[1];
        dfs(1, 0);
        res.insert(res.begin(), hashrt, hashrt+n+1);
        return res;
    }    
}
```

## 矩阵树定理

The following content is from Introduction to Linear Algebra-Wellesley-Cambridge Press (2016)

Let $G = (V, E)$ be an undirected finite graph with $n$ vertices and $m$ edges. We
also consider weighted graphs with a weight function that assigns a non-negative
real weight $a_{vw}$ to each pair $v$, $w$ of vertices. We require that the weights satisfy
the following properties:
* $a_{vw} > 0$ if $v,w \in E$, and $a_{vw} = 0$ if $v,w \not \in E$ 
* $a_{vw} = a_{wv}$, for all $v,w \in V$

Unweighted graphs can be viewed as weighted graphs in which $a_{vw}$ is the number of edges between $v$ and $w$

In the unweighted case, the degree $\deg v$ of a vertex $v \in V$ is the number of edges of $G$ incident with $v$. In the weighted case, it is defined by $\deg v = \sum\limits_{w\in V}a_{vw}$

Given a graph $G$, its (weighted) adjacency matrix $A(G) = (a_{vw})$ is the $n \times n$
matrix, with rows and columns indexed by $V$, whose entries are the edge-weights.

The degree matrix $D(G) = diag(\deg v : v \in V)$ is the diagonal matrix indexed by $V$ with the vertex-degrees on the diagonal. The difference $L(G) = D(G) − A(G)$ is the Laplace matrix (or Laplacian) of G

Let $G$ be a graph and let $L = L(G)$ be its Laplace matrix. If $T$ is a spanning tree of $G$, let $a(T)$ be the product of the edgeweights of $T$ . For any vertices $v$ and $w$, the (weighted) number of spanning trees
of $G$ is

$$
 \pi{(G)} = \sum\{a(T ) : \textrm{T is a spanning tree of G}\}=|\det  L_{v}^{w}|
$$

where $L_{v}^{w}$ is the submatrix of $L$ obtained by deleting the column corresponding to $v$ and the row corresponding to $w$

## 最短路 

```cpp
namespace dijkstra {
typedef int Cost;
typedef pair<int, Cost> E;
typedef pair<int, int> P;

vector<E> G[N];
void addEdge(int u, int v, Cost w) {
    G[u].emplace_back(v, w);
    G[v].emplace_back(u, w);
}
template <typename T>
void dij(int s, int n, T d[], int t = 0) {
    // d[s] = 0;
    priority_queue< pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> pq;
    pq.empace(0, s);
    // sort();
    memset(d, -1, sizeof(d[0]) * (n + 1));
    d[s] = 0;
    while (!pq.empty()) {
        auto now = pq.top();
        pq.pop();
        if (now.second == t)
            return;
        int u = now.second;
        T dis = now.first;
        for (const auto &e : G[u]) {
            int v = e.first;
            Cost w = e.second;
            if (dis + w < d[v]) {
                d[v] = dis + w;
                pq.emplace(d[v], v);
            }
        }
    }
}
}  // namespace dijkstra
```

+ spfa

```cpp
template<typename T>
struct E {
    int to;
    T cost;
    E(int to=0, T cost=0):to(to), cost(cost){}
};

template<typename T>
struct Spfa {
    int n;

    static const T INF = 0x3f3f3f3f;
    vector<vector<E<T>>> G;
    void init(int n) {
        this->n = n;
        G.resize(n+1);
        for (int i=0; i<=n; ++i)
            G[i].clear();
    }

    void addEdge(int u, int v, T cost) {
        // dbg(u, v, cost, n);
        assert(u <= n && v <= n);
        G[u].push_back(E<T>(v, cost));
    }

    void go(int s, T d[], int f[]) {
        fill(d, d+n+1, INF);
        d[s] = 0;
        queue<int> q;
        q.push(s);

        static bool in[N];
        memset(in, 0, sizeof(bool) * (n+1));
        in[s] = 1;
        f[s] = -1;
            
        while (!q.empty()) {
            auto u = q.front();
            q.pop();
            in[u] = false;
            // dbg(u, d[u]);
            for (const auto &e : G[u]) {
                int v = e.to; T w = e.cost;
                if (d[u] + w < d[v]) {
                    d[v] = d[u] + w;
                    f[v] = u;
                    if (!in[v]) {
                        in[v] = 1;
                        q.push(v);
                    }
                }
            }
        }
    }

    vector<int> findPath(int s, int t, T d[], int f[]) {
        vector<int> res;
        res.reserve(n);
        for (int v=t; v!=s; v=f[v]) {
            res.push_back(v);
        }
        res.push_back(s);
        reverse(res.begin(), res.end());
        return res;
    }
};
```

## 最小割树

从整个图开始每次随便选两个点进行网络流求最小割，割出来的的两个点集继续进行类似运算，随机选两个点再割直到只剩一个点位置。每次作最小割都是对整个图（原图）进行运算，相当与作 $n$ 次 dinic。然后把两个点连带最小割的值当成树上要加的一条带权边。最小割树建好之后任意两点之间的最小割相当于在树上经过各个边的权值最小值

需要 dinic, 树上倍增（或hld

+ `vector<pair<int, int>> G[]` 为要建立的边
+ PS：luogu 的数据太傻逼了，标号正常的连通图和std 对拍了一万年（小数据和大数据）都是 ok 的

```cpp
struct MinCutTree
{
    dinic::Dinic dc;

    bool deep[N];
    int *u, *v, *w, n, m;
    int node[N], tmp1[N], tmp2[N];

    vector<pair<int, int>> *G;

    void add(int u, int v, int w)
    {
        G[u].emplace_back(v, w);
        G[v].emplace_back(u, w);
    }

    void init(int n, int m, int u[], int v[], int w[], vector<pair<int, int>> G[])
    {
        this->n = n;
        this->m = m;
        this->u = u;
        this->v = v;
        this->w = w;
        this->G = G;
        dbg("mct.init", n, m);
        for (int i=0; i<m; ++i)
            dbg(i, u[i], v[i], w[i]);
    }

    void build(int l, int r)
    {
        if (l == r)
            return;
        int s = node[l], t = node[l + 1];
        dc.init(n, m, s, t, u, v, w);
        int res = dc.go();
        dc.cut(deep, 1, n);
        dbg(s, t, res);
        add(s, t, res);
        int tcnt1 = 0, tcnt2 = 0;
        for (int i = l; i <= r; ++i)
        {
            if (deep[node[i]])
                tmp1[tcnt1++] = node[i];
            else
                tmp2[tcnt2++] = node[i];
        }
        // int ncnt = 0;
        for (int i = 0; i < tcnt1; ++i)
            node[l + i] = tmp1[i];
        for (int i = 0; i < tcnt2; ++i)
            node[l + tcnt1 + i] = tmp2[i];
        build(l, l + tcnt1 - 1);
        build(l + tcnt1, r);
    }

    void go()
    {
        for (int i = 1; i <= n; ++i)
            node[i] = i;
        build(1, n);
    }
} mct;
```

## 全局最小割 StoerWagner

#### 概念：

+ 无向图的割：有无向图 $G=(V,E)$，设 $C$ 为图 $G$ 中一些弧的集合，若从 $G$ 中删去 $C$ 中的所有弧能使图 $G$ 不是连通图，称 $C$ 图 $G$
的一个割。
+ $S−T$ 割：使得顶点 $S$ 与顶点T不再连通的割，称为 $S−T割$
+ $S−T$ 最小割：包含的弧的权和最小的 $S−T$ 割，称为 $S−T$ 最小割。
+ 全局最小割：包含的弧的权和最小的割，称为全局最小割。
+ 诱导割 (induced cut)：令图 $G=(V,E)$ 的一个割为 $C$，则割 $C$ 在图 $G$ 的子图 $G′=(V′,E′)$ 中的部分称为割 $C$ 的诱导割。（类似于概念诱导子图(induced subgraph)）

#### 流程

```python
def MinimumCutPhase(G, w, a):
    A ← {a}
    while A ≠ V:
        把与A联系最紧密（most tightly）的顶点加入A中
    cut-of-the-phase ← w(A \ t, t)
    合并最后两个加入到A的顶点s、t
    return cut-of-the-phase

def StoerWagner(G, w, a):
    while |V| > 1
        MinimumCutPhase(G, w, a)
        根据返回值更新最小割
```

#### 代码

+ $O(V^3)$ 常数不（太）大
+ 邻接矩阵存储

```cpp
const int N = 605;
int g[N][N];
namespace stoerwagner
{
    int id[N];
    int add(int g[N][N], int a, int m)
    {
        static int S[N], scnt;
        static int cmp[N];
        static bool in[N];
        
        scnt = 0;
        memset(cmp, 0, sizeof(cmp[0]) * (m + 1));
        memset(in, 0, sizeof(in[0]) * (m + 1));

        S[scnt++] = id[a]; in[a] = 1;

        int mini = 0, minv = 0;

        while (scnt < m)
        {
            mini = -1; minv = -1;
            for (int i=1; i<=m; ++i)
            {
                if (in[i]) continue;
                cmp[i] += g[id[i]][S[scnt-1]];
                if (cmp[i] > minv)
                {
                    minv = cmp[i];
                    mini = i;
                }
            }
            S[scnt++] = id[mini];
            in[mini] = true;
        }

        int s = S[scnt-1], t = S[scnt-2];

        if (s > t) swap(s, t);
        for (int i=1; i<=m; ++i)
        {
            g[s][id[i]] += g[t][id[i]];
            g[id[i]][s] += g[t][id[i]];
            g[t][id[i]] = g[id[i]][t] = 0;
        }

        for (int i=1; i<=m; ++i)
        {
            if (id[i] == t)
            {
                for (int j=i+1; j<=m; ++j)
                    id[j-1] = id[j];
                break;
            }
        }
        return minv;
    }

    int go(int g[N][N], int n, int a = 1)
    {
        int m = n;
        for (int i=1; i<=m; ++i)
            id[i] = i;
        int ans = 0x7fffffff;
        for (; m > 1; --m)
        {
            ans = min(ans, add(g, a, m));
        }
        return ans;
    }
}
```

邻接表版本 HDU 6081 7000ms 左右，常数很大的样子，复杂度不是严格的 $O(VE + V^2logV)$

```cpp

const int N = 3e3 + 5,
          M = 1e6 * 2 + 50,
          INF = 0x3f3f3f3f;

struct Edge
{
    int to, next, w;
} e[M];
int ecnt;
int head[N], tail[N], link[N];

struct dsu
{
    int f[N];
    void init(int n)
    {
        for (int i = 0; i <= n; ++i)
            f[i] = i;
    }
    int find(int x)
    {
        return x == f[x] ? x : (f[x] = find(f[x]));
    }
    bool connect(int x, int y)
    {
        x = find(x);
        y = find(y);
        f[x] = y;
        return x != y;
    }

    bool test(int x, int y)
    {
        x = find(x);
        y = find(y);
        return x != y;
    }
} ds;

int n, m;
void init(int n)
{
    memset(head, -1, sizeof(int) * (n + 1));
    ds.init(n);
    ecnt = 0;
}

void add_edge(int u, int v, int w)
{
    e[ecnt] = {v, head[u], w};
    head[u] = ecnt++;
    e[ecnt] = {u, head[v], w};
    head[v] = ecnt++;
}

namespace stoerwagner
{
int mincutphase(int cnt, int &s, int &t)
{
    static bool vis[N];
    static int val[N];

    memset(vis + 1, 0, sizeof(vis[0]) * n);
    memset(val + 1, 0, sizeof(int) * n);

    priority_queue<pair<int, int>> que;
    t = 1;
    while (--cnt)
    {
        vis[s = t] = true;
        for (int u = s; ~u; u = link[u])
        {
            for (int p = head[u]; ~p; p = e[p].next)
            {
                int v = ds.find(e[p].to);
                if (!vis[v])
                {
                    que.push(make_pair(val[v] += e[p].w, v));
                }
            }
        }
        t = 0;
        while (!t)
        {
            if (que.empty())
                return 0; // not connected graph
            auto pa = que.top();
            que.pop();
            if (val[pa.second] == pa.first)
                t = pa.second;
        }
    }
    return val[t];
}
int go()
{
    int res = 0x7fffffff;
    for (int i = 1; i <= n; ++i)
    {
        tail[i] = i;
        link[i] = -1;
    }
    for (int i = n, s, t; i > 1; --i)
    {
        res = min(res, mincutphase(i, s, t));
        if (res == 0)
            break;
        if (s > t)
            swap(s, t);
        ds.connect(s, t);
        link[tail[t]] = s;
        tail[t] = tail[s];
    }
    return res;
}
} // namespace stoerwagner
```

## LCA

+ 倍增

```cpp
void dfs(int u, int fa) {
    pa[u][0] = fa; dep[u] = dep[fa] + 1;
    FOR (i, 1, SP) pa[u][i] = pa[pa[u][i - 1]][i - 1];
    for (int& v: G[u]) {
        if (v == fa) continue;
        dfs(v, u);
    }
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    int t = dep[u] - dep[v];
    FOR (i, 0, SP) if (t & (1 << i)) u = pa[u][i];
    FORD (i, SP - 1, -1) {
        int uu = pa[u][i], vv = pa[v][i];
        if (uu != vv) { u = uu; v = vv; }
    }
    return u == v ? u : pa[u][0];
}
```

## 树上差分

对一堆路径上的边或点作区间加法后，最后询问每个边或点的权值

如果整体加上 `x` :

+ 点 `(u,v), lca(u,v) = o, f[o] = p` ： `diff[u]+=x,diff[v]+=x,diff[o]-=x,diff[p]-=x;`
+ 边 `diff[u]+=x,diff[v]+=x,diff[o]-=2*x;`

## 网络流

+ 最大流

```cpp
namespace dinic
{
struct E
{
    int to;
    LL cp;
    E(int to = 0, LL cp = 0) : to(to), cp(cp) {}
};
struct Dinic
{
    static const int INF = 0x7fffffff;
    int m, s, t, n;

    E edges[M];
    int ecnt;
    vector<int> G[N];

    int d[N], cur[N];

    void init(int n, int s, int t)
    {
        this->s = s;
        this->t = t;
        this->n = n;
        ecnt = m = 0;
        for (int i = 0; i <= n; ++i)
            G[i].clear();
    }

    void addedge(int u, int v, LL cap)
    {
        edges[ecnt++] = E(v, cap);
        edges[ecnt++] = E(u, 0);
        G[u].push_back(m++);
        G[v].push_back(m++);
    }

    bool bfs()
    {
        memset(d, 0, sizeof(int) * (n + 2));
        queue<int> Q;
        Q.push(s);
        d[s] = 1;
        while (!Q.empty())
        {
            int x = Q.front();
            Q.pop();
            for (int &i : G[x])
            {
                E &e = edges[i];
                if (!d[e.to] && e.cp > 0)
                {
                    d[e.to] = d[x] + 1;
                    Q.push(e.to);
                }
            }
        }
        return d[t];
    }

    LL DFS(int u, LL cp)
    {
        if (u == t || !cp)
            return cp;
        LL tmp = cp;
        LL f;
        for (int &i = cur[u]; i < (int)G[u].size(); ++i)
        {
            E &e = edges[G[u][i]];
            if (d[u] + 1 == d[e.to])
            {
                f = DFS(e.to, min(cp, e.cp));
                e.cp -= f;
                edges[G[u][i] ^ 1].cp += f;
                cp -= f;
                if (!cp)
                    break;
            }
        }
        return tmp - cp;
    }

    LL go(int S = -1, int T = -1)
    {
        if ((~S) && (~T))
        {
            s = S;
            t = T;
        }
        LL flow = 0;
        while (bfs())
        {
            memset(cur, 0, sizeof(int) * (n + 1));
            flow += DFS(s, INF);
        }
        return flow;
    }

};
} // namespace dinic
```

+ 费用流

+ zkw 费用流（代码长度没有优势）
+ 不允许有负权边

```cpp
struct E {
    int to, cp, v;
    E() {}
    E(int to, int cp, int v): to(to), cp(cp), v(v) {}
};

struct MCMF {
    int n, m, s, t, cost, D;
    vector<E> edges;
    vector<int> G[maxn];
    bool vis[maxn];

    void init(int _n, int _s, int _t) {
        n = _n; s = _s; t = _t;
        FOR (i, 0, n + 1) G[i].clear();
        edges.clear(); m = 0;
    }

    void addedge(int from, int to, int cap, int cost) {
        edges.emplace_back(to, cap, cost);
        edges.emplace_back(from, 0, -cost);
        G[from].push_back(m++);
        G[to].push_back(m++);
    }

    int aug(int u, int cp) {
        if (u == t) {
            cost += D * cp;
            return cp;
        }
        vis[u] = true;
        int tmp = cp;
        for (int idx: G[u]) {
            E& e = edges[idx];
            if (e.cp && !e.v && !vis[e.to]) {
                int f = aug(e.to, min(cp, e.cp));
                e.cp -= f;
                edges[idx ^ 1].cp += f;
                cp -= f;
                if (!cp) break;
            }
        }
        return tmp - cp;
    }

    bool modlabel() {
        int d = INF;
        FOR (u, 0, n + 1)
            if (vis[u])
                for (int& idx: G[u]) {
                    E& e = edges[idx];
                    if (e.cp && !vis[e.to]) d = min(d, e.v);
                }
        if (d == INF) return false;
        FOR (u, 0, n + 1)
            if (vis[u])
                for (int& idx: G[u]) {
                    edges[idx].v -= d;
                    edges[idx ^ 1].v += d;
                }
        D += d;
        return true;
    }

    int go(int k) {
        cost = D = 0;
        int flow = 0;
        while (true) {
            memset(vis, 0, sizeof vis);
            int t = aug(s, INF);
            if (!t && !modlabel()) break;
            flow += t;
        }
        return cost;
    }
} MM;
```

+ dij 费用流
+ 对负权费用流的优化，改变负权后最短路变成 dij 了

```cpp
namespace mcf {
    const int N = 1e5+50;
    template<typename T>
    struct E {
        int to, cp;
        T cost;
        int rev;
        E(int to=0, int cp=0, T cost=0, int rev=0):to(to), cp(cp), cost(cost), rev(rev){}
    };

    template<typename T>
    struct Mcmf {
        int v, prev[N], pree[N];
        T h[N], dis[N];
        vector<E<T>> G[N];
        void init(int n) {
            v = n;
            for (int i=0; i<=v; ++i)
                G[i].clear();
        }
        void addEdge(int from, int to, int cp, T cost) {
            G[from].emplace_back(to, cp, cost, G[to].size());
            G[to].emplace_back(from, 0, -cost, G[from].size()-1);
        }
        T go(int s, int t, int f, int &flow) {
            const T INF = 0x3f3f3f3f;
            T res = 0;
            memset(h, 0, sizeof (h[0]) * (v + 1));
            while (f) {
                priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;
                fill(dis, dis+v+1, INF);
                dis[s] = 0;
                q.emplace(0, s);
                while (!q.empty()) {
                    auto now = q.top();
                    q.pop();
                    int v = now.second;
                    if (dis[v] < now.first)
                        continue;
                    for (int i=0; i<sz(G[v]); ++i) {
                        auto &e = G[v][i];
                        if (e.cp > 0 && dis[e.to] > dis[v] + e.cost + h[v] - h[e.to]) {
                            dis[e.to] = dis[v] + e.cost + h[v] - h[e.to];
                            prev[e.to] = v;
                            pree[e.to] = i;
                            q.emplace(dis[e.to], e.to);
                        }
                    }
                }
                if (dis[t] == INF)
                    break;
                for (int i=0; i<=v; ++i)
                    h[i] += dis[i];
                int d = f;
                for (int v=t; v!=s; v=prev[v])
                    d = min(d, G[prev[v]][pree[v]].cp);
                f -= d;
                flow += d;
                res += d * h[t];
                for (int v=t; v!=s; v=prev[v]) {
                    auto &e = G[prev[v]][pree[v]];
                    e.cp -= d;
                    G[v][e.rev].cp += d;
                }
            }
            return res;
        }
    };
}
```

### 带下界网络流：

+ 无源汇：$u \rightarrow v$ 边容量为 $[l,r]$，连容量 $r-l$，虚拟源点到 $v$ 连 $l$，$u$ 到虚拟汇点连 $l$。检查时查看 $S$ 的出边是否都是满流
+ `edges` 中的边号 前 `0-m-1 * 2` 为图中的边及其反向边
+ 之后跟着是超级源点汇点的边
+ 反向边的 `cp` 便是原边的流量

判断是否形成循环流，如果能 `printTrace` 输出每条边的流量

```cpp
class extdinic1
{
public:
    dinic::Dinic dc;
    int S, T;
    LL tf[N];
    LL sum;
    void init(int n, int m, int u[], int v[], int w1[], int w2[])
    {
        S = ++n; T = ++n;
        dc.init(n, S, T);
        memset(tf, 0, sizeof(LL) * (n+1));
        for (int i=0; i<m; ++i)
        {
            tf[v[i]] += w1[i];
            tf[u[i]] -= w1[i];
            dc.addedge(u[i], v[i], w2[i] - w1[i]);
        }
        sum = 0;
        for (int i=1; i<=n-2; ++i)
        {
            if (tf[i] < 0)
            {
                dc.addedge(i, T, -tf[i]);
            }
            else if (tf[i] > 0)
            {
                dc.addedge(S, i, tf[i]);
                sum += tf[i];
            }
        }
    }

    LL go()
    {
        LL ans = dc.go();
        if (ans != sum) return -1;
        else return ans;
    }
};
```


+ 有源汇：为了让流能循环使用，连 $T \rightarrow S$，容量 $\infty$。
+ 最大流：跑完可行流后，加 $S' \rightarrow S$，$T \rightarrow T'$，最大流就是答案（$T \rightarrow S$ 的流量自动退回去了，这一部分就是下界部分的流量）。

```cpp
class extdinic2 : public extdinic1
{
public:
    static const LL INF = 1e18;
    int s, t;

    void init(int n, int m, int s, int t, int u[], int v[], int w1[], int w2[])
    {
        this->s = s; this->t = t;
        extdinic1::init(n, m, u, v, w1, w2);
    }   
    LL go()
    {
        dc.addedge(t, s, INF);
        LL ans = extdinic1::go(); if (ans == -1) return -1;
        ans = dc.go(s, t);
        return ans;
    }
} dc;
```

+ 最小流：$T$ 到 $S$ 的那条边的实际流量，减去删掉那条边后 $T$ 到 $S$ 的最大流。
+ loj117
+ 网上说可能会减成负的，还要有限地供应 $S$ 之后，再跑一遍 $S$ 到 $T$ 的。

```cpp
class extdinic3 : public extdinic2
{
public:
    LL go()
    {
        dc.addedge(t, s, INF);
        LL ans = extdinic1::go();
        if (ans == -1) return -1;
        ans = dc.edges[dc.ecnt-1].cp;
        dc.edges[dc.ecnt-1].cp = dc.edges[dc.ecnt-2].cp = 0;
        ans -= dc.go(t, s);
        return ans;
    }   
} dc;
```

+ 最小费用可行（最小费用）流：模仿带下界可行流，构造循环流。下界部分的钱事先算好，连边就不要钱了，然后只跑两个界限之间的费用。流量是假的，好像只能用费用？好像这样是最小的费用？

loj2226

```cpp
class extmcf1
{
public:
    mcf::Mcmf mcf;
    int d[N];
    int sum, S, T, s, t;
    int baseCost;
    void init(int n, int m, int s, int t, int u[], int v[], int c[], int w1[], int w2[])
    {
        memset(d, 0, sizeof(int) * (n + 1));
        sum = baseCost = 0; S = ++n; T = ++n;
        this->s = s; this->t = t;
        mcf.init(n);


        for (int i=0; i<m; ++i)
        {
            d[v[i]] += w1[i];
            d[u[i]] -= w1[i];
            sum += w1[i];
            baseCost += w1[i] * c[i];
            mcf.addEdge(u[i], v[i], w2[i] - w1[i], c[i]);
        }

        for (int i=1; i<=n; ++i)
        {
            if (d[i] > 0)
            {
                mcf.addEdge(S, i, d[i], 0);
            }
            else if (d[i] < 0)
            {
                mcf.addEdge(i, T, -d[i], 0);
            }
        }

        mcf.addEdge(t, s, 0x3f3f3f3f, 0);
    }  

    int go(int &flow)
    {
        flow = 0;
        int cost = baseCost;
        // printf("baseCost=%d\n", baseCost);
        cost += mcf.go(S, T, 0x3f3f3f3f, flow);
        flow += d[t];
        return cost;
    }
} mcmf;
```

## 树链剖分

+ `top, f, d, rid` 给出 id[v]，`dep, id, fa, son, siz` 给出原始 id
+ 使用 `init`

```cpp
const int N = 500000+5;

int dep[N], id[N], fa[N];
vector<int> G[N];

namespace HLD {
    int top[N], d[N], f[N], son[N], rid[N];
    int dfn;

    int siz[N];

    void dfs1(int u, int la, int depth) {
        dep[u] = depth;
        fa[u] = la;
        son[u] = -1;
        siz[u] = 1;
        for (int v : G[u]) {
            if (v == la) continue;
            dfs1(v, u, depth+1);
            siz[u] += siz[v];
            if (!~son[u] || siz[v] > siz[son[u]])
                son[u] = v;
        }
    }

    void dfs2(int u, int la, int t) {
        id[u] = ++dfn;
        rid[id[u]] = u;
        top[id[u]] = id[t];
        d[id[u]] = dep[u];
        f[id[u]] = id[la];

        for (int v : G[u]) {
            if (v == la) continue;
            if (v == son[u]) dfs2(v, u, t);
            else dfs2(v, u, v);
        }
    }

    int lca(int u, int v) {
        for (u=id[u], v=id[v];top[u]!=top[v]; u=f[top[u]]) {
            if (d[top[u]] < d[top[v]]) swap(u, v);
        }
        if (d[u] < d[v]) swap(u, v);
        return rid[v];
    }

    void init(int root) {
        dfn = 0;
        dfs1(root, root, 1);
        dfs2(root, root, root);
    }

    // non-checked
    int up(int u, int step) {
        for (u=id[u]; step; u=f[u], --step) {
            int t = min(d[u] - d[top[u]], step);
            u -= t;
            step -= t;
        }
        return rid[u];
    }

    // non-checked
    int finds(int u, int rt) { // find the lowest v that is the ancestor of u
        u = id[u]; rt = id[rt];
        while (top[u] != top[rt]) {
            u = top[u];
            if (fa[u] == rt) return u;
            u = fa[u];
        }
        return rid[rt + 1];
    }
}

```
## 二分图匹配

+ 最小覆盖数 = 最大匹配数
+ 最大独立集 = 顶点数 - 二分图匹配数
+ DAG 最小路径覆盖数 = 结点数 - 拆点后二分图最大匹配数


+ 二分图最大权完美匹配 KM

```cpp
namespace R {
    const int M = 400 + 5;
    const int INF = 2E9;
    int n;
    int w[M][M], kx[M], ky[M], py[M], vy[M], slk[M], pre[M];

    LL KM() {
        FOR (i, 1, n + 1)
            FOR (j, 1, n + 1)
                kx[i] = max(kx[i], w[i][j]);
        FOR (i, 1, n + 1) {
            fill(vy, vy + n + 1, 0);
            fill(slk, slk + n + 1, INF);
            fill(pre, pre + n + 1, 0);
            int k = 0, p = -1;
            for (py[k = 0] = i; py[k]; k = p) {
                int d = INF;
                vy[k] = 1;
                int x = py[k];
                FOR (j, 1, n + 1)
                    if (!vy[j]) {
                        int t = kx[x] + ky[j] - w[x][j];
                        if (t < slk[j]) { slk[j] = t; pre[j] = k; }
                        if (slk[j] < d) { d = slk[j]; p = j; }
                    }
                FOR (j, 0, n + 1)
                    if (vy[j]) { kx[py[j]] -= d; ky[j] += d; }
                    else slk[j] -= d;
            }
            for (; k; k = pre[k]) py[k] = py[pre[k]];
        }
        LL ans = 0;
        FOR (i, 1, n + 1) ans += kx[i] + ky[i];
        return ans;
    }
}
```

## 欧拉路径

```cpp
int S[N << 1], top;
Edge edges[N << 1];
set<int> G[N];

void DFS(int u) {
    S[top++] = u;
    for (int eid: G[u]) {
        int v = edges[eid].get_other(u);
        G[u].erase(eid);
        G[v].erase(eid);
        DFS(v);
        return;
    }
}

void fleury(int start) {
    int u = start;
    top = 0; path.clear();
    S[top++] = u;
    while (top) {
        u = S[--top];
        if (!G[u].empty())
            DFS(u);
        else path.push_back(u);
    }
}
```

## 强连通分量与 2-SAT

需要加边，定义 `sat::n` 表示总节点个数，记得开双倍点

+ a || b: (a',b), (b',a)
+ a: (a', a)
+ !a: (a, a')
+ 其他的先作变换然后再套上面公式
+ sat::cmp[a] > sat::cmp[a'] 表示选a，如果相等则无解

```cpp
namespace sat
{
const int N = 2e6 + 5;
int n;
vector<int> G[N], rG[N], vs;
int used[N], cmp[N];

void add_edge(int from, int to)
{
    G[from].push_back(to);
    rG[to].push_back(from);
}

void dfs(int v)
{
    dbg(v);
    used[v] = true;
    for (int u : G[v])
    {
        if (!used[u])
            dfs(u);
    }
    vs.push_back(v);
}

void rdfs(int v, int k)
{
    dbg(v, k);
    used[v] = true;
    cmp[v] = k;
    for (int u : rG[v])
        if (!used[u])
            rdfs(u, k);
}

int scc() {
    memset(used, 0, sizeof(used));
    vs.clear();
    for (int v = 1; v <= n; ++v)
        if (!used[v]) dfs(v);
    memset(used, 0, sizeof(used));
    int k = 0;
    for (int i = (int) vs.size() - 1; i >= 0; --i)
        if (!used[vs[i]]) rdfs(vs[i], k++);
    return k;
}


} // namespace sat
```

## 一般图匹配

带花树。复杂度 $O(n^3)$。

```cpp
int n;
vector<int> G[N];
int fa[N], mt[N], pre[N], mk[N];
int lca_clk, lca_mk[N];
pair<int, int> ce[N];

void connect(int u, int v) {
    mt[u] = v;
    mt[v] = u;
}
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }

void flip(int s, int u) {
    if (s == u) return;
    if (mk[u] == 2) {
        int v1 = ce[u].first, v2 = ce[u].second;
        flip(mt[u], v1);
        flip(s, v2);
        connect(v1, v2);
    } else {
        flip(s, pre[mt[u]]);
        connect(pre[mt[u]], mt[u]);
    }
}

int get_lca(int u, int v) {
    lca_clk++;
    for (u = find(u), v = find(v); ; u = find(pre[u]), v = find(pre[v])) {
        if (u && lca_mk[u] == lca_clk) return u;
        lca_mk[u] = lca_clk;
        if (v && lca_mk[v] == lca_clk) return v;
        lca_mk[v] = lca_clk;
    }
}

void access(int u, int p, const pair<int, int>& c, vector<int>& q) {
    for (u = find(u); u != p; u = find(pre[u])) {
        if (mk[u] == 2) {
            ce[u] = c;
            q.push_back(u);
        }
        fa[find(u)] = find(p);
    }
}

bool aug(int s) {
    fill(mk, mk + n + 1, 0);
    fill(pre, pre + n + 1, 0);
    iota(fa, fa + n + 1, 0);
	vector<int> q = {s};
	mk[s] = 1;
    int t = 0;
    for (int t = 0; t < (int) q.size(); ++t) {
        // q size can be changed
        int u = q[t];
        for (int &v: G[u]) {
            if (find(v) == find(u)) continue;
            if (!mk[v] && !mt[v]) {
                flip(s, u);
                connect(u, v);
                return true;
            } else if (!mk[v]) {
                int w = mt[v];
                mk[v] = 2; mk[w] = 1;
                pre[w] = v; pre[v] = u;
                q.push_back(w);
            } else if (mk[find(v)] == 1) {
                int p = get_lca(u, v);
                access(u, p, {u, v}, q);
                access(v, p, {v, u}, q);
            }
        }
    }
    return false;
}

int match() {
    fill(mt + 1, mt + n + 1, 0);
    lca_clk = 0;
    int ans = 0;
    FOR (i, 1, n + 1)
        if (!mt[i]) ans += aug(i);
    return ans;
}

int main() {
    int m; cin >> n >> m;
    while (m--) {
        int u, v; scanf("%d%d", &u, &v);
        G[u].push_back(v); G[v].push_back(u);
    }
    printf("%d\n", match());
    FOR (i, 1, n + 1) printf("%d%c", mt[i], i == _i - 1 ? '\n' : ' ');
    return 0;
}

```

## Tarjan

### 简单缩环

+ 每个点最多属于一个简单环
+ 缩完点之后是一颗树
+ 利用返祖边遍历每一个环
+ `G` 是原图下标从 0 开始， `G2` 是缩点之后的图下标从 1 开始
+ vis 表示 `G2` 中该点是不是原来的一个环
 
```cpp
namespace simplecc {
    int fa[N], dep[N];

    int bl[N], B;

    bool vis[N];

    void init(int n) {
        B = 0;
        memset(dep, 0, sizeof(int) * (n + 1));
        memset(bl, 0, sizeof(int) * (n + 1));
    }

    void get(int x, int y) {
        if (dep[x] < dep[y]) return;
        bl[y] = ++B; vis[B] = 1;
        for (; x!=y; x=fa[x]) bl[x] = B;
    }

    void dfs(int u, int f) {
        fa[u] = f;
        dep[u] = dep[f] + 1;

        for (int v : G[u]) {
            if (v == f) continue;
            if (dep[v]) get(u, v);
            else dfs(v, u);
        }
    }

    void go(int n) {
        init(n);
        dfs(0, 0);
        for (int i=0; i<n; ++i) {
            if (!bl[i]) bl[i] = ++B;
        }

        for (int i=0; i<n; ++i) {
            for (int j : G[i]) {
                int u = bl[i], v = bl[j];
                if (u != v) G2[u].push_back(v);
            }
        }
    }
}
```

### 割点

+ 判断割点
+ 注意原图可能不连通

```cpp
int dfn[N], low[N], clk;
void init() { clk = 0; memset(dfn, 0, sizeof dfn); }
void tarjan(int u, int fa) {
    low[u] = dfn[u] = ++clk;
    int cc = fa != -1;
    for (int& v: G[u]) {
        if (v == fa) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            cc += low[v] >= dfn[u];
        } else low[u] = min(low[u], dfn[v]);
    }
    if (cc > 1) // ...
}
```

### 桥

+ 注意原图不连通和重边

```cpp
int dfn[N], low[N], clk;
void init() { memset(dfn, 0, sizeof dfn); clk = 0; }
void tarjan(int u, int fa) {
    low[u] = dfn[u] = ++clk;
    int _fst = 0;
    for (E& e: G[u]) {
        int v = e.to; if (v == fa && ++_fst == 1) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            if (low[v] > dfn[u]) // ...
            low[u] = min(low[u], low[v]);
        } else low[u] = min(low[u], dfn[v]);
    }
}
```

### 强连通分量缩点

+ `vector<int> G[N]` 准备好
+ 别忘了不连通的情况
+ `go` 把整个图的缩圈都搞了

```cpp
namespace tarjan {
    int low[N], dfn[N], clk, B, bl[N];
    vector<int> bcc[N];
    void init(int n) {
        B = clk = 0;
        memset(dfn, 0, sizeof(int) * (n+1));
        for (int i=0; i<n; ++i) bcc[i].clear();
    }

    void tarjan(int u) {
        static int st[N], p;
        static bool in[N];
        dfn[u] = low[u] = ++clk;
        st[p++] = u; in[u] = true;
        for (int &v : G[u]) {
            if (!dfn[v]) {
                tarjan(v);
                low[u] = min(low[u], low[v]);
            } else if (in[v]) low[u] = min(low[u], dfn[v]);
        }
        if (dfn[u] == low[u]) {
            while (1) {
                int x = st[--p]; in[x] = false;
                bl[x] = B; bcc[B].push_back(x);
                if (x == u) break;
            }
            ++ B;
        }
    }

    void go(int n) {
        init(n);
        for (int i=0; i<n; ++i) {
            if (!dfn[i]) tarjan(i);
        }
    }
}
```

### 点双连通分量 / 广义圆方树

+ 数组开两倍
+ 一条边也被计入点双了（适合拿来建圆方树），可以用 点数 <= 边数 过滤

```cpp
struct E { int to, nxt; } e[N];
int hd[N], ecnt;
void addedge(int u, int v) {
    e[ecnt] = {v, hd[u]};
    hd[u] = ecnt++;
}
int low[N], dfn[N], clk, B, bno[N];
vector<int> bc[N], be[N];
bool vise[N];
void init() {
    memset(vise, 0, sizeof vise);
    memset(hd, -1, sizeof hd);
    memset(dfn, 0, sizeof dfn);
    memset(bno, -1, sizeof bno);
    B = clk = ecnt = 0;
}

void tarjan(int u, int feid) {
    static int st[N], p;
    static auto add = [&](int x) {
        if (bno[x] != B) { bno[x] = B; bc[B].push_back(x); }
    };
    low[u] = dfn[u] = ++clk;
    for (int i = hd[u]; ~i; i = e[i].nxt) {
        if ((feid ^ i) == 1) continue;
        if (!vise[i]) { st[p++] = i; vise[i] = vise[i ^ 1] = true; }
        int v = e[i].to;
        if (!dfn[v]) {
            tarjan(v, i);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) {
                bc[B].clear(); be[B].clear();
                while (1) {
                    int eid = st[--p];
                    add(e[eid].to); add(e[eid ^ 1].to);
                    be[B].push_back(eid);
                    if ((eid ^ i) <= 1) break;
                }
                ++B;
            }
        } else low[u] = min(low[u], dfn[v]);
    }
}
```

## 圆方树

+ 从仙人掌建圆方树
+ N 至少边数 × 2

```cpp
vector<int> G[N];
int nn;

struct E { int to, nxt; };
namespace C {
    E e[N * 2];
    int hd[N], ecnt;
    void addedge(int u, int v) {
        e[ecnt] = {v, hd[u]};
        hd[u] = ecnt++;
    }
    int idx[N], clk, fa[N];
    bool ring[N];
    void init() { ecnt = 0; memset(hd, -1, sizeof hd); clk = 0; }
    void dfs(int u, int feid) {
        idx[u] = ++clk;
        for (int i = hd[u]; ~i; i = e[i].nxt) {
            if ((i ^ feid) == 1) continue;
            int v = e[i].to;
            if (!idx[v]) {
                fa[v] = u; ring[u] = false;
                dfs(v, i);
                if (!ring[u]) { G[u].push_back(v); G[v].push_back(u); }
            } else if (idx[v] < idx[u]) {
                ++nn;
                G[nn].push_back(v); G[v].push_back(nn); // 强行把环的根放在最前面
                for (int x = u; x != v; x = fa[x]) {
                    ring[x] = true;
                    G[nn].push_back(x); G[x].push_back(nn);
                }
                ring[v] = true;
            }
        }
    }
}
```

## 最小树形图

+ tarjan做法

```cpp
const int N=3e5+10;
const LL INF=1e15;
typedef pair<LL,int> P;

struct MTD
{
    set<P> G[N];
    LL shift[N];
    bool vis[N];
    int n,m,stk[N],top,fa[N];
    int Fa(int x){return fa[x]==x?x:fa[x]=Fa(fa[x]);}
    void init(int _n,int _m)
    {
        n=_n;m=_m;
        for (int i=0;i<=n;i++) fa[i]=i;
    }
    LL solve()
    {
        LL ans=0;
        for (int i=2;i<=n;i++)
        {
            int u=i;top=0;
            while(Fa(u)!=Fa(1))
            {
                vis[u]=true;stk[top++]=u;
                auto it=G[u].begin();
                while(it!=G[u].end())
                {
                    int v=it->second;
                    if (Fa(v)==Fa(u)) it=G[u].erase(it);
                    else break;
                }
                if(it==G[u].end())return -INF;
                LL lb=it->first;
                int v=it->second;
                G[u].erase(it);
                v=Fa(v);
                ans+=lb+shift[u];
                shift[u]=-lb;
                if(vis[v] && Fa(v)!=Fa(1))
                {
                    int x=v;
                    while(stk[top-1]!=v)
                    {
                        int y=stk[--top];
                        fa[Fa(y)]=Fa(x);
                        if(G[x].size()<G[y].size()) G[x].swap(G[y]),swap(shift[x],shift[y]);
                        for(auto pr: G[y])
                            G[x].insert(P(pr.first+shift[y]-shift[x],pr.second));
                        G[y].clear();
                    }
                }
                u=v;
            }
            while(top--) fa[Fa(stk[top])]=1;
        }
        for (int i=2;i<=n;i++)
            if(Fa(i)!=Fa(1)) return -INF;
        return ans;
    }
}tree;

int n,m;

int main()
{
    scanf("%d%d",&n,&m);
    tree.init(n,m);
    int u,v,w;
    for (int i=0;i<m;i++)
        scanf("%d%d%d",&u,&v,&w),tree.G[v].insert(P(w,u));
    LL ans=tree.solve();
    if (ans==-INF) puts("NO");else printf("%lld\n",ans);
}

```

## 差分约束

一个系统 $n$ 个变量和 $m$ 个约束条件组成，每个约束条件形如 $x_j-x_i \le b_k$。可以发现每个约束条件都形如最短路中的三角不等式 $d_u-d_v \le w_{u,v}$。因此连一条边 $(i,j,b_k)$ 建图。

若要使得所有量两两的值最接近，源点到各点的距离初始成 $0$，跑最远路。

若要使得某一变量与其他变量的差尽可能大，则源点到各点距离初始化成 $\infty$，跑最短路。

最短路版本：luogu p5960

```cpp

const int N = 5e3 + 5;
typedef pair<int, int> edge;
vector<edge> G[N];
int n, m;
namespace spfa
{
bool in[N];
int cnt[N];

bool go(int s, int dist[], int n)
{
    memset(in, 0, sizeof(in[0]) * (n + 1));
    memset(cnt, 0, sizeof(cnt[0]) * (n + 1));
    memset(dist, 0x3f3f3f3f, sizeof(dist[0]) * (n + 1));

    dist[s] = 0;
    cnt[s] = 1;
    in[s] = 1;
    queue<int> Q;
    Q.push(s);

    while (!Q.empty())
    {
        int now = Q.front();
        // printf("now=%d\n", now);
        Q.pop(); in[now] = false;
        for (const auto &p : G[now])
        {
            int v = p.first, cost = p.second;
            // printf("now=%d, v=%d, cost=%d\n", now, v, cost);
            if (dist[v] > dist[now] + cost)
            {
                dist[v] = dist[now] + cost;
                if (!in[v])
                {
                    ++cnt[v];
                    if (cnt[v] > n)
                        return true;
                    in[v] = true;
                    Q.push(v);
                }
            }
        }
    }
    return false;
}
} // namespace spfa

inline void add(int u, int v, int w)
{
    // printf("%d %d %d\n", u, v, w);
    G[u].emplace_back(v, w);
}

int a[N][3], x[N];
namespace diff_constraint
{
bool go(int a[][3], int x[], int n)
{
    for (int i=1; i<=n; ++i)
        G[i].clear();
    for (int i=0; i<n; ++i)
    {
        add(a[i][1], a[i][0], a[i][2]);
    }
    for (int i=1; i<=n; ++i)
        add(n+1, i, 0);
    return spfa::go(n+1, x, n+1);
}
}
```

## 三元环、四元环

### 四元环

考虑这样一个四元环，将答案统计在度数最大的点 $b$ 上。考虑枚举点 $u$，然后枚举与其相邻的点 $v$，然后再枚举所有度数比 $v$ 大的与 $v$ 相邻的点，这些点显然都可能作为 $b$ 点，我们维护一个计数器来计算之前 $b$ 被枚举多少次，答案加上计数器的值，然后计数器加一。

枚举完 $u$ 之后，我们用和枚举时一样的方法来清空计数器就好了。 

任何一个点，与其直接相连的度数大于等于它的点最多只有 $\sqrt{2m}$ 个。所以复杂度 $O(m \sqrt{m})$。

```cpp
LL cycle4() {
    LL ans = 0;
    iota(kth, kth + n + 1, 0);
    sort(kth, kth + n, [&](int x, int y) { return deg[x] < deg[y]; });
    FOR (i, 1, n + 1) rk[kth[i]] = i;
    FOR (u, 1, n + 1)
        for (int v: G[u])
            if (rk[v] > rk[u]) key[u].push_back(v);
    FOR (u, 1, n + 1) {
        for (int v: G[u])
            for (int w: key[v])
                if (rk[w] > rk[u]) ans += cnt[w]++;
        for (int v: G[u])
            for (int w: key[v])
                if (rk[w] > rk[u]) --cnt[w];
    }
    return ans;
}
```

### 三元环

将点分成度入小于 $\sqrt{m}$ 和超过 $\sqrt{m}$ 的两类。现求包含第一类点的三元环个数。由于边数较少，直接枚举两条边即可。由于一个点度数不超过 $\sqrt{m}$，所以一条边最多被枚举 $\sqrt{m}$ 次，复杂度 $O(m \sqrt{m})$。再求不包含第一类点的三元环个数，由于这样的点不超过 $\sqrt{m}$ 个，所以复杂度也是 $O(m \sqrt{m})$。

对于每条无向边 $(u,v)$，如果 $d_u < d_v$，那么连有向边 $(u,v)$，否则有向边 $(v,u)$。度数相等的按第二关键字判断。然后枚举每个点 $x$，假设 $x$ 是三元组中度数最小的点，然后暴力往后面枚举两条边找到 $y$，判断 $(x,y)$ 是否有边即可。复杂度也是 $O(m \sqrt{m})$。

```cpp
int cycle3() {
    int ans = 0;
    for (E &e: edges) { deg[e.u]++; deg[e.v]++; }
    for (E &e: edges) {
        if (deg[e.u] < deg[e.v] || (deg[e.u] == deg[e.v] && e.u < e.v))
            G[e.u].push_back(e.v);
        else G[e.v].push_back(e.u);
    }
    FOR (x, 1, n + 1) {
        for (int y: G[x]) p[y] = x;
        for (int y: G[x]) for (int z: G[y]) if (p[z] == x) ans++;
    }
    return ans;
}
```

##  支配树

+ `semi[x]` 半必经点（就是 $x$ 的祖先 $z$ 中，能不经过 $z$ 和 $x$ 之间的树上的点而到达 $x$ 的点中深度最小的）
+ `idom[x]` 最近必经点（就是深度最大的根到 $x$ 的必经点）

```cpp
vector<int> G[N], rG[N];
vector<int> dt[N];

namespace tl{
    int fa[N], idx[N], clk, ridx[N];
    int c[N], best[N], semi[N], idom[N];
    void init(int n) {
        clk = 0;
        fill(c, c + n + 1, -1);
        FOR (i, 1, n + 1) dt[i].clear();
        FOR (i, 1, n + 1) semi[i] = best[i] = i;
        fill(idx, idx + n + 1, 0);
    }
    void dfs(int u) {
        idx[u] = ++clk; ridx[clk] = u;
        for (int& v: G[u]) if (!idx[v]) { fa[v] = u; dfs(v); }
    }
    int fix(int x) {
        if (c[x] == -1) return x;
        int &f = c[x], rt = fix(f);
        if (idx[semi[best[x]]] > idx[semi[best[f]]]) best[x] = best[f];
        return f = rt;
    }
    void go(int rt) {
        dfs(rt);
        FORD (i, clk, 1) {
            int x = ridx[i], mn = clk + 1;
            for (int& u: rG[x]) {
                if (!idx[u]) continue;  // 可能不能到达所有点
                fix(u); mn = min(mn, idx[semi[best[u]]]);
            }
            c[x] = fa[x];
            dt[semi[x] = ridx[mn]].push_back(x);
            x = ridx[i - 1];
            for (int& u: dt[x]) {
                fix(u);
                if (semi[best[u]] != x) idom[u] = best[u];
                else idom[u] = x;
            }
            dt[x].clear();
        }

        FOR (i, 2, clk + 1) {
            int u = ridx[i];
            if (idom[u] != semi[u]) idom[u] = idom[idom[u]];
            dt[idom[u]].push_back(u);
        }
    }
}

int main()
{
    int x,p,q;
    scanf("%d%d%d",&n,&m,&x);
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d",&p,&q);
        G[p].push_back(q);
    }
    tree.init(n);
    tree.go(x);
}
```

## 边双连通分量

+ 邻接表编写
+ 边从0开始标号，点从1开始
+ init()清空，go()搞好id[]，也就是缩点编号
+ POJ3177, ZOJ4097

```cpp
vector<int> u, v;
namespace EDCC {
vector<int> dfn, low, id;
vector<bool> insta;
stack<int> sta;

int edcc;
vector< vector< pair<int, int> > > G;
int clk;

void init(int n) {
    clk = 0;
    dfn.resize(n+1);
    fill(dfn.begin(), dfn.end(), 0);
    low.resize(n+1);
    fill(low.begin(), low.end(), 0);
    G.resize(n+1);
    FOR (i, 1, n+1)
        G[i].clear();
    id.resize(n+1);
    fill(id.begin(), id.end(), 0);
    while (!sta.empty()) sta.pop();
    insta.resize(n+1);
    fill(insta.begin(), insta.end(), 0);
    edcc = 0;
}

void add(int a, int b, int id) {
    if (a != b) {
        G[a].push_back(make_pair(b, id));
        G[b].push_back(make_pair(a, id));
    }
}

void tarjan(int now, int fa, int reid) {
    // dbg("tarjan", now);
    dfn[now] = ++clk;
    low[now] = dfn[now];
    insta[now] = 1;
    sta.push(now);
    for (const pii &e:G[now]) {
        int nt = e.first, eid = e.second;
        if (eid == reid) continue;
        if (!dfn[nt]) {
            tarjan(nt, now, eid);
            low[now] = min(low[nt], low[now]);
        } else if (insta[nt]) 
            low[now] = min(dfn[nt], low[now]);
    }
    
    if (dfn[now] == low[now]) {
        ++edcc;
        while (!sta.empty()) {
            int v = sta.top();
            id[v] = edcc;
            insta[v] = 0;
            sta.pop();
            if (v == now) break;   
        }
    }
}
void go(int n) {
    FOR (i, 0, sz(u)) {
        add(u[i], v[i], i);
    }
    FOR (i, 1, n+1) {
        if (!dfn[i]) {
            if (!sta.empty()) {
                while(1){}
            }
            tarjan(i, i, -1);
        }
    }
}
}

```