# 数据结构
## pbds

头文件：

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/priority_queue.hpp>
#include <ext/pb_ds/trie_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
```

### hash

用于替代 `unordered_map` 整数插入操作 stl 3.6s, pbds 探测法 2s

```cpp
gp_hash_table<int, int> mp;
cc_hash_table<int, int> mp2;
```

### tree

1. 用来替代 `map`，第二个类型填 `null_type` 就是 `set`
2. key 会 自动去重


example:

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
tree<int, int, greater<int>, rb_tree_tag, tree_order_statistics_node_update> tr;

/*
int key 类型 int value 类型，可用 null_type 替代
less<int> 表示 key 从小到大，对应 greater<int>
rb_tree_tag 红黑树，可用 splay_tree_tag 替代
insert erase order_by_key find_by_order
lower_bound upper_bound
a.join(b) 将 b 并入 a
a.split(v, b) 将 key <= v 保留给 a，其他给 b
*/

int main(int argc, char const *argv[])
{
    tr.insert(make_pair(2, 2));
    tr.insert(make_pair(1, 1));
    tr.find(1)->second ++;
    for (auto x : tr)
        cout << x.first << ' ' << x.second << endl;
    puts("===");
    tr.insert(make_pair(1, 3));
    for (auto x : tr)
        cout << x.first << ' ' << x.second << endl;
    puts("===");
    tr.erase(1);
    for (int i=0; i<tr.size(); ++i)
    {
        auto p = tr.find_by_order(i);
        cout << p->first << ' ' << p->second << ' ' << tr.order_of_key(p->first) << endl;
    }
    puts("===");
    auto x = tr.lower_bound(1);
    cout << (x == tr.end()) << endl;
    return 0;
}
/* outcome
2 2
1 2
===
2 2
1 2
===
2 2 0
===
1
*/
```
## ST 表

### standard

```cpp
int p2[10], Log[N];
struct ST {
    static const int SP = 10;
    int dat[SP][N];
    void init() {
        p2[0] = 1;
        for (int i=1; i<SP; ++i)
            p2[i] = p2[i-1] << 1;
        Log[1] = 0;
        for (int i=2; i<N; ++i)
            Log[i] = Log[i >> 1] + 1;
    }
    void init(int a[], int n)
    {
        for (int i=1; i<=n; ++i)
            dat[0][i] = a[i];
        for (int i=1; i<SP; ++i)
            for (int j=1; j<=n; ++j)
                dat[i][j] = min(dat[i-1][j], dat[i-1][j + p2[i-1]]);
    }
    int q(int l, int r) {
        int Lg = Log[r-l+1];
        return min(dat[Lg][l], dat[Lg][r-p2[Lg]+1]);
    }
} ds[N];
```