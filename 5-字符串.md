# 字符串

## SA

+ n：串长
+ m：字符集大小
+ s[0..n−1]：字符串
+ sa[1..n]：字典序第i小的是哪个后缀
+ rank[0..n−1]：后缀i的排名
+ height[i]：lcp(sa[i], sa[i−1])

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rank _rank
const int N = 1e5+50;
int n, rank[N], sa[N], height[N], tmp[N], cnt[N];
char s[N];
void suffixarray(int n, int m)
{
    int i, j, k;
    n++;
    for (i = 0; i < n * 2 + 5; i++)
        rank[i] = sa[i] = height[i] = tmp[i] = 0;
    for (i = 0; i < m; i++)
        cnt[i] = 0;
    for (i = 0; i < n; i++)
        cnt[rank[i] = s[i]]++;
    for (i = 1; i < m; i++)
        cnt[i] += cnt[i-1];
    for (i = 0; i < n; i++)
        sa[--cnt[rank[i]]] = i;
    for (k = 1; k <= n; k <<= 1)
    {
        for (i = 0; i < n; i++)
        {
            j = sa[i]-k;
            if (j < 0)
                j += n;
            tmp[cnt[rank[j]]++] = j;
        }
        sa[tmp[cnt[0] = 0]] = j = 0;
        for (i = 1; i < n; i++)
        {
            if (rank[tmp[i]] != rank[tmp[i-1]] || rank[tmp[i] + k] != rank[tmp[i-1] + k])
                cnt[++j] = i;
            sa[tmp[i]] = j;
        }
        memcpy(rank, sa, n * sizeof(int));
        memcpy(sa, tmp, n * sizeof(int));
        if (j >= n-1)
            break;
    }
    for (j = rank[height[i = k = 0] = 0]; i < n-1; i++, k++)
        while (~k && s[i] != s[sa[j-1] + k])
            height[j] = k--, j = rank[sa[j] + 1];
}

```